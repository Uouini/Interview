# 操作系统 #
## 死锁 ##
- 死锁：死锁是指多个进程因竞争资源而造成的一种僵局（互相等待）
- 产生条件：互斥条件、请求与保护、不可剥夺、循环等待
- 预防死锁：资源一次性分配（破开请求条件）、只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）、只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）、资源有序分配法，系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

## LRU怎么在外存中找到需要的页 ##
- doing

## LRU怎么找到最久未使用的页 ##
- doing

## 进程间通讯 ##
1. 无名管道PIPE:管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系
2. 有名管道FIFO:有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信
3. 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
4. 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信
5. 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源
6. 套接字：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信
7. 信号： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

## 线程间通讯 ##
1. 锁机制：互斥锁、条件变量、读写锁
2. 信号量机制：包括无名线程信号量和命名线程信号量
3. 信号机制：线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制

## 进程、线程、协程 ##
- 进程：进程是系统进行资源分配和调度的基本单位，每一个进程都有它自己的地址空间
- 线程：线程是进程的一个实体,是CPU调度和分派的基本单位，共享进程所拥有的全部资源
- 协程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈

## 软链接与硬链接 ##
- 软链接：ln -s 源文件 目标文件，存放的是另一个文件的路径指向，与快捷方式差不多
- 硬链接：ln 源文件 目标文件，一个inode对应多个文件，即同一个文件多个别名

## 文件时间 ##
- ctime：文件的元数据发生变化，比如权限、所有者等（change time）
- atime：文件最后被访问的时间（access time）
- mtime：文件修改的最后时间（modify time）

## 进程调度算法 ##
- 时间片轮转调度算法（RR）：给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行
- 先来先服务调度算法（FCFS）：根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象
- 优先级调度算法（HPF）：进程优先级高的先执行
- 多级反馈队列调度算法：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转
- 高响应比优先调度算法：根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度

## 页面置换算法 ##
- 最佳置换（OPT）：发生缺页时，选择内存中最远要被访问的页面置换出去（理想算法）
- 先进先出（FIFO）：发生缺页时，把先进入内存的页先置换出去
- 最近最久未使用：（LRU）：发生却也时，把在最近一段时间最久没有使用过的页面置换出去
- 最近未使用：（NRU）：发生缺页时，把最近 未使用的页置换出去

## 系统默认栈空间大小 ##
- window：1M
- linux：8M或10M

## fork与vfork ##
- fork：子进程拷贝父进程的数据段和代码段，父子进程的执行次序不确定
- vfork：子进程与父进程共享数据段，子进程先运行，xit之后父进程才可能被调度运行

## 并行与并发 ##
- 并发：多个事件在同一时间段执行
- 并行：多个事件在同一时间执行

## 同步与异步 ##
- 同步：发出调用时，必须等调用返回再执行下一步
- 异步：发出调用时，不必等调用返回，执行其它事件，调用完成后再通知继续执行该事件

## 阻塞与非阻塞 ##
- 阻塞：发出调用时，调用结果返回前，线程挂起，等待结果返回再继续执行
- 非阻塞：发出调用时，不会挂起当前线程，直接返回

## 五种I/O模型 ##
- 阻塞I/O：程序调用一个I/O函数时，程序阻塞，直到数据准备好（recv()、recvfrom()）
- 非阻塞I/O：当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果，需要轮询数据是否准备好
- 多路复用I/0：在多路复用IO模型中，会有一个线程不断去轮询多个文件描述符的状态，只有当文件描述符真正有读写事件触发时，才真正调用实际的IO读写操作
- 信号驱动I/O: 在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的IO事件发生注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作
- 异步I/O：异步I/O不会阻塞用户线程，内核准备好数据后发出信号，告诉用户线程可以使用数据了

