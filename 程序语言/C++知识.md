#C++知识
##1.static关键字##
- 静态变量：存储在静态存储区，未经初始化的全局静态变量会被自动初始化为0
- 静态函数：静态函数声明只在当前文件可见，不能被其他文件所用
- 类的静态成员：静态成员是类的所有对象中共享的成员，而不是某个对象的成员
- 类的静态函数：静态成员函数不能直接引用类中的非静态成员，实例化一个对象，通过对象访问非静态成员变量
## 2.C与C++的区别 ##
- 设计思想上：C++是面向对象的语言，而C是面向过程的结构化编程语言
- 语法上：C++具有封装、继承和多态三种特性,支持范式编程，比如模板类、函数模板等
## 3.C++四种类型转换 ##
1. static_cast：一般用于基本数据类型之间的转换
2. const_cast：用于将const变量转为非const
3. dynamic_cast：动态类型转换，类层次间的向上或向下转换，只能转指针或引用。向下转换，非法指针返回NULL
4. reinterpret_cast：强制转换任何类型
## 4.引用与指针的区别 ##
- 引用：引用就是变量的一个别名，对引用的操作与对变量直接操作完全一样
- 指针：指针是一个变量，其值为另一个变量的地址。
- 区别：指针有自己的一块空间，而引用只是一个别名；sizeof值，指针的大小是4，引用则引用对象的大小；指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；指针在可以指向其它对象，引用只能是一个对象的引用，不能改变；
## 5.C++四个智能指针 ##
1. auto_ptr：
2. unique_ptr：同一时间内只有一个智能指针可以指向对象
3. shared_ptr：多个智能指针可以指向一个对象，当引用计数器为0时，自动释放资源
4. weak_ptr：解决shared_ptr相互引用时的死锁问题，它是对象的一种弱引用，不会增加对象的引用计数器
## 6.野指针 ##
- 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针
## 7.析构函数必须为虚函数 ##
- 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏
- C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
## 8.fork函数 ##
- pid_t fork(void);成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。

## 9.静态函数和虚函数的区别 ##
- 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。静态成员函数只能直接访问静态成员变量和静态成员函数

## 10.重载与覆盖的区别 ##
- 重载：两个函数名相同，参数列表不同（个数，类型），返回值类型没有要求
- 覆盖：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数

## 11.虚函数和多态 ##
- 静态多态：静态多态主要是重载，在编译的时候就已经确定
- 动态多态：动态多态是用虚函数机制实现的，在运行期间动态绑定