#C++知识
## static关键字 ##
- 静态变量：存储在静态存储区，未经初始化的全局静态变量会被自动初始化为0（初始值零）
- 静态函数：静态函数声明只在当前文件可见，不能被其他文件所用（隐藏作用）
- 类的静态成员：静态成员是类的所有对象中共享的成员，而不是某个对象的成员
- 类的静态函数：静态成员函数不能直接引用类中的非静态成员，类外初始化

## const关键字 ##
- 常量：定义必须初始化
- 常量指针：指针的值不能改变
- 指针常量：指针指向的值不能改变

## C与C++的区别 ##
- 设计思想上：C++是面向对象的语言，而C是面向过程的结构化编程语言
- 语法上：C++具有封装、继承和多态三种特性,支持范式编程，比如模板类、函数模板等
## C++四种类型转换 ##
1. static_cast：一般用于基本数据类型之间的转换
2. const_cast：用于将const变量转为非const
3. dynamic_cast：动态类型转换，类层次间的向上或向下转换，只能转指针或引用。向下转换，非法指针返回NULL
4. reinterpret_cast：强制转换任何类型
## 引用与指针的区别 ##
- 引用：引用就是变量的一个别名，对引用的操作与对变量直接操作完全一样
- 指针：指针是一个变量，其值为另一个变量的地址。
- 区别：指针有自己的一块空间，而引用只是一个别名；sizeof值，指针的大小是4，引用则引用对象的大小；指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；指针在可以指向其它对象，引用只能是一个对象的引用，不能改变；
## C++四个智能指针 ##
1. auto_ptr：
2. unique_ptr：同一时间内只有一个智能指针可以指向对象
3. shared_ptr：多个智能指针可以指向一个对象，当引用计数器为0时，自动释放资源
4. weak_ptr：解决shared_ptr相互引用时的死锁问题，它是对象的一种弱引用，不会增加对象的引用计数器
## 野指针 ##
- 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针
## 7.析构函数必须为虚函数 ##
- 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们
- 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏
- C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
## fork函数 ##
- pid_t fork(void);成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。

## 静态函数和虚函数的区别 ##
- 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。静态成员函数只能直接访问静态成员变量和静态成员函数

## 重载与覆盖的区别 ##
- 重载：两个函数名相同，参数列表不同（个数，类型），返回值类型没有要求
- 覆盖：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数

## 虚函数和多态 ##
- 静态多态：静态多态主要是重载，在编译的时候就已经确定
- 动态多态：动态多态是用虚函数机制实现的，在运行期间动态绑定

## 在main函数前执行的函数 ##
- __attribute((constructor)) void before() {}

## shared_ptr原理 ##
- 智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放

## const修饰成员函数的目的 ##
- const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数

## new/delete与malloc/free的区别 ##
- new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数

## RTTI原理 ##
- 运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info

## C++处理返回值 ##
- 生成一个临时变量，把它的引用作为函数参数传入函数内

## C++中拷贝赋值函数的形参不能值传递 ##
- 调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数，。如此循环，无法完成拷贝，栈也会满

## STL迭代器删除元素 ##
- 对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器
- 对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可
- 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用

## C++源文件从文本到可执行文件经历的过程 ##
1. 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件
2. 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
3. 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
4. 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件

## 发生段错误 ##
- 访问非法内存地址：野指针、修改字符串常量

## nullptr和NULL区别 ##
- Nullptr是空指针。NULL在c++中是数值常量0。在某些情况下，使用NULL存在二义性问题。比如两个重载函数，参数分别是整型和指针类型。此时使用NULL存在二义性问题

##哪些函数不能声明为虚函数 ##
- 非成员函数：非成员函数只能被重载，不能被继承，而虚函数主要的作用是在继承中实现动态多态。非成员函数早在编译期间就已经绑定函数，无法实现动态多态，那声明成虚函数则无意义
- 构造函数
- 静态成员函数：静态成员函数对于每个类来说只有一份，所有的对象共享一份代码。它是属于类而不属于对象。虚函数必须根据对象类型才能知道调用哪一个虚函数，故虚函数是一定要在对象的基础上。两者一个与实例相关，一个与类相关
- 静态成员函数：静态成员函数对于每个类来说只有一份，所有的对象共享一份代码。它是属于类而不属于对象。虚函数必须根据对象类型才能知道调用哪一个虚函数，故虚函数是一定要在对象的基础上。两者一个与实例相关，一个与类相关
- 内联函数：内联函数是为了在代码中直接展开，减少函数调用开销。虚函数是为了在继承后对象能够准确的执行自己的动作，并且inline函数在编译时被展开，虚函数在运行时才能动态绑定函数

## 析构函数能否抛出异常 ##
- 异常点之后的代码不会被执行，存在资源泄漏可能
- 异常之后如果再抛出异常，多个异常情况下，c++直接终止程序退出

## 内联函数和宏定义区别 ##
- 宏定义是在预处理期间替换，内联函数是在编译期间替换
- 宏定义仅作字符串替换，内联函数会有类型检查，更安全

## C++空的结构体和空类大小，含有虚函数呢 ##
- C++中空的结构体和空类大小为1，这是为了区分不同的空类或空结构体。含有虚函数的空对象大小为一个虚函数指针大小，32位操作系统是4，64位是8。注意，多重继承情况下，大小和虚函数指针个数有关

## strlen()与size()的区别 ##
- size()运算符：在编译的时候计算，参数可以是数组（数组空间大小）、指针（一般为4）、类（类占用空间大小）、对象（对象占用空间大小）、函数（函数返回类型的大小）
- strlen()函数：运行时计算，参数必须是字符串指针（char*），计算字符串长度，直到遇到结束符“\0",当数组名作为参数时，退化为指针

## String insert底层 ##
- doing

## 堆与栈的区别 ##
- 栈：栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈，内存地址由高到底
- 堆：堆由开发人员分配和释放，分配方式类似于链表，内存地址由低到高

## 查看内存泄漏工具 ##
- Valgrind:未释放内存的使用、对释放后内存的读/写、对已分配内存块尾部的读/写、内存泄露、不匹配的使用malloc/new/new[] 和 free/delete/delete[]、重复释放内存

## C++容器 ##
- 顺序容器：vector、list、deque
- 关联容器：set、map

## 类的大小 ##
- class A{};sizeof(A) == 1
- class A{ virtual func(){} };sizeof(A) == 4
- class A{ static int a; };sizeof(A) = 1
- class A{ int a; };sizeof(A) == 4
- class A{ static int a; int b; };sizeof(A) == 4

## 静态绑定与动态绑定 ##
- 静态类型：对象在声明时采用的类型，在编译期既已确定
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期
- 绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定

## c++多态为何只能通过指针或引用实现 ##
- 因为对象的类型在编译期就确定了，指针或引用是在运行期根据他们绑定的具体对象确定
- C++中，通过基类的引用或指针调用虚函数时，发生动态绑定。引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的
- C++中动态绑定是通过虚函数实现的。而虚函数是通过一张虚函数表（virtual table）实现的。这个表中记录了虚函数的地址，解决继承、覆盖的问题，保证动态绑定时能够根据对象的实际类型调用正确的函数

## 零拷贝技术 ##
- 零拷贝主要的任务就是避免CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝
- 使用mmap,直接建立内存映射，不用把数据从内核空间拷贝到用户空间

## C++构造函数 ##
- 默认构造函数：默认构造函数不带参数
- 一般构造函数：一般构造函数带参数，可以进行重载构造函数
- 拷贝构造函数：拷贝构造函数参数为类对象本身的引用，根据一个存在的对象复制出一个新的该类对象

## 构造函与普通函数##
- 构造函数无返回值，函数名必须与类名一致，若一个类没有定义构造函数，编译器默认创建

## 浅拷贝与深拷贝 ##
- 浅拷贝：浅拷贝就是对象数据成员之间的简单复制赋值，若数据成员中有指针，则两个类的指针指向同一个地址，析构函数会执行两次，出现悬空指针
- 深拷贝：深拷贝为对象创建新的内存地址，再赋值到新的内存上，类中有指针、引用、堆、文件时必须用深拷贝
- 主要区别：深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝

## 调用拷贝构造函数 ##
1. 用类的一个对象初始化另一个对象
2. 当函数的形参是类的对象（值传递）
3. 函数返回值是类的对象

## 为什么要进行内存对齐 ##
1. 移植原因：不是所有的平台都能访问任意地址上的任意数据，某些平台只能在某些地址取特定类型的数据
2. 性能原因：访问未对齐的内存，处理器需要要访问两次内存（CPU有存储粒度，不是每个字节存储）

## 内存泄漏 ##
- 定义：内存泄漏是指程序未能释放不再使用的内存，失去了对该段内存的控制
- 堆内存泄漏：malloc、new分配的动态内存，未调用对应的free、delete释放
- 系统资源泄漏：程序使用系统分配的资源（Bitmap、handle、socket）没有相应的函数释放

## 构造函数初始化列表 ##
- 构造函数执行的两个阶段：初始化阶段（初始化类成员）、计算阶段（构造函数体内赋值操作）
- 类成员的初始化：使用初始化列表或构造函数体内赋值。对于内置类型两种初始化无太大差别，使用初始化类别初始化其它类型，能减少一次默认构造函数的调用
- 必须使用初始化列表：常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面；引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面；没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
- 初始化顺序：成员是按照他们在类中定义的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的

## C++11新特性 ##
1. 支持long long类型，扩展精度浮点数，10位有效数字
2. 变量初始化int a(0)、int a{0}
3. nullptr常量，*p = nullptr、*p = 0、 *p = NULL三者等价
4. auto类型指示符，让编译器通过初始值来推算变量的类型，所以，其定义的变量必须要有初始值
5. for语句,for(auto c : strs)
6. =default,告诉编译器生成默认构造函数
7. lambda表达式 int ret = [](int a, b){return a+b;}
8. 智能指针stared_ptr、weak_ptr

## 函数压栈过程 ##
- 函数的各个参数从右向左逐个压入栈中，最后压入函数返回地址

